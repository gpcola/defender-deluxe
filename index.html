<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Defender Deluxe</title>

  <!-- Open Graph / Social -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Defender Deluxe – A Modern Browser Remake">
  <meta property="og:description" content="A neon-soaked browser remake of Defender: pure Canvas + WebAudio, no assets, daily challenge & leaderboard.">
  <meta property="og:url" content="https://gpcola.github.io/defender-deluxe/">
  <meta property="og:image" content="https://gpcola.github.io/defender-deluxe/og-image.svg">
  <meta name="twitter:card" content="summary_large_image">

  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#03040a">
  <style>
    html, body { margin:0; height:100%; background:#03040a; color:#d7e0ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas { display:block; width:100vw; height:100vh; }
    .ui {
      position: fixed; inset: 0; pointer-events: none;
      display:flex; align-items:flex-start; justify-content:space-between;
      padding: 12px; gap: 12px;
    }
    .panel {
      pointer-events:auto;
      background: rgba(0,0,0,0.42);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
      max-width: min(520px, calc(100vw - 24px));
    }
    .row { display:flex; gap: 8px; flex-wrap: wrap; align-items:center; }
    .row > * { margin: 0; }
    .small { font-size: 12px; opacity: 0.85; line-height: 1.35; }
    .btn {
      pointer-events:auto;
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: #d7e0ff;
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      user-select:none;
    }
    .btn:hover { background: rgba(255,255,255,0.10); }
    .btn:active { transform: translateY(1px); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; padding: 2px 6px; border-radius: 8px; border:1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.05); }
    .rightCol { display:flex; flex-direction:column; gap: 10px; align-items:flex-end; }
    .drawer {
      width: min(420px, calc(100vw - 24px));
      display:none;
    }
    .drawer.open { display:block; }
    .field { display:flex; justify-content:space-between; gap: 10px; align-items:center; padding: 6px 0; border-bottom: 1px dashed rgba(255,255,255,0.10); }
    .field:last-child { border-bottom: none; }
    input[type="text"]{
      width: 180px; max-width: 48vw;
      border-radius: 10px; border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.25);
      color:#d7e0ff; padding: 7px 9px;
    }

    /* Touch controls */
    .touchPad {
      position: fixed; inset: 0; display:none;
      pointer-events:none;
    }
    .touchPad.show { display:block; }
    .touchBtn {
      pointer-events:auto;
      position: absolute;
      width: 80px; height: 80px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(8px);
      display:flex; align-items:center; justify-content:center;
      color:#d7e0ff; font-weight: 700;
      user-select:none;
      touch-action: none;
    }
    .touchBtn::after{
      content:"";
      position:absolute; inset: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .touchBtn.active { background: rgba(255,255,255,0.10); }
    .touchHint {
      position: fixed; left: 12px; right: 12px; bottom: 12px;
      display:none;
      pointer-events:none;
      text-align:center;
      font-size: 12px;
      opacity: 0.85;
    }
    .touchHint.show{ display:block; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="ui">
    <div class="panel">
      <div class="row" style="justify-content:space-between; width:100%;">
        <div><b>Defender Deluxe</b> <span class="small">by PowerrTarget</span></div>
        <div class="row">
          <button class="btn" id="btnPlay">Play</button>
          <button class="btn" id="btnDaily">Daily</button>
          <button class="btn" id="btnShare">Share</button>
          <button class="btn" id="btnOptions">Options</button>
        </div>
      </div>
      <div class="small" style="margin-top:8px">
        <span class="kbd">←</span>/<span class="kbd">→</span> rotate · <span class="kbd">↑</span> thrust · <span class="kbd">Space</span> fire ·
        <span class="kbd">Shift</span> hyperspace · <span class="kbd">B</span> smart bomb · <span class="kbd">P</span> pause
      </div>
      <div class="small" style="margin-top:6px">
        Protect humans. Landers abduct → if lost, they become Mutants. Rescue by hovering near a human.
      </div>
    </div>

    <div class="rightCol">
      <div class="panel drawer" id="drawer">
        <div class="row" style="justify-content:space-between">
          <b>Options</b>
          <button class="btn" id="btnClose">Close</button>
        </div>

        <div class="field">
          <span class="small">Reddit username</span>
          <input id="inpReddit" type="text" placeholder="PowerTarget" />
        </div>

        <div class="field">
          <span class="small">Sound</span>
          <button class="btn" id="togSound">On</button>
        </div>

        <div class="field">
          <span class="small">CRT Scanlines</span>
          <button class="btn" id="togCRT">On</button>
        </div>

        <div class="field">
          <span class="small">Reduce motion</span>
          <button class="btn" id="togMotion">Off</button>
        </div>

        <div class="field">
          <span class="small">Touch controls</span>
          <button class="btn" id="togTouch">Auto</button>
        </div>

        <div class="field">
          <span class="small">Leaderboard</span>
          <button class="btn" id="btnRefreshLB">Refresh</button>
        </div>

        <div class="small" id="lb" style="margin-top:10px; white-space:pre-wrap"></div>
      </div>
    </div>
  </div>

  <div class="touchPad" id="touchPad">
    <div class="touchBtn" id="tLeft"  style="left: 18px; bottom: 110px;">⟲</div>
    <div class="touchBtn" id="tRight" style="left: 116px; bottom: 110px;">⟳</div>
    <div class="touchBtn" id="tThrust" style="right: 116px; bottom: 110px;">↑</div>
    <div class="touchBtn" id="tFire" style="right: 18px; bottom: 110px;">●</div>
    <div class="touchBtn" id="tBomb" style="right: 18px; bottom: 18px; width: 88px; height: 52px; border-radius: 16px;">BOMB</div>
    <div class="touchBtn" id="tHyper" style="right: 116px; bottom: 18px; width: 88px; height: 52px; border-radius: 16px;">HYPER</div>
  </div>
  <div class="touchHint" id="touchHint">Touch controls enabled. You can turn them off in Options.</div>

<script>
(() => {
  // ================
  // Config (yours)
  // ================
  const GITHUB_OWNER = "gpcola";
  const GITHUB_REPO  = "defender-deluxe";
  const REPO_PAGES_URL = `https://${GITHUB_OWNER}.github.io/${GITHUB_REPO}/`;

  // Reddit usernames do not usually contain spaces; adjust if needed:
  const REDDIT_USERNAME_DEFAULT = "Power target";

  // ================
  // Canvas
  // ================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize);
  resize();

  // ================
  // Helpers
  // ================
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const wrap = (x, w) => (x % w + w) % w;
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };
  function wrapDx(dx, worldW) {
    if (dx >  worldW/2) dx -= worldW;
    if (dx < -worldW/2) dx += worldW;
    return dx;
  }

  // ================
  // Local storage settings
  // ================
  const LS_KEY = "defender_deluxe_settings_v1";
  const defaultSettings = {
    redditName: REDDIT_USERNAME_DEFAULT,
    sound: true,
    crt: true,
    reduceMotion: false,
    touch: "auto" // auto | on | off
  };
  const settings = { ...defaultSettings, ...(safeJson(localStorage.getItem(LS_KEY)) || {}) };
  function saveSettings() { localStorage.setItem(LS_KEY, JSON.stringify(settings)); }

  function safeJson(s){ try { return JSON.parse(s); } catch { return null; } }

  // ================
  // UI wiring
  // ================
  const drawer = document.getElementById("drawer");
  const lbEl = document.getElementById("lb");

  const btnPlay = document.getElementById("btnPlay");
  const btnDaily = document.getElementById("btnDaily");
  const btnShare = document.getElementById("btnShare");
  const btnOptions = document.getElementById("btnOptions");
  const btnClose = document.getElementById("btnClose");
  const btnRefreshLB = document.getElementById("btnRefreshLB");

  const inpReddit = document.getElementById("inpReddit");
  const togSound = document.getElementById("togSound");
  const togCRT = document.getElementById("togCRT");
  const togMotion = document.getElementById("togMotion");
  const togTouch = document.getElementById("togTouch");

  inpReddit.value = settings.redditName || "";
  setBtn(togSound, settings.sound ? "On" : "Off");
  setBtn(togCRT, settings.crt ? "On" : "Off");
  setBtn(togMotion, settings.reduceMotion ? "On" : "Off");
  setBtn(togTouch, settings.touch.toUpperCase());

  btnOptions.onclick = () => drawer.classList.toggle("open");
  btnClose.onclick = () => drawer.classList.remove("open");

  inpReddit.oninput = () => { settings.redditName = inpReddit.value.trim(); saveSettings(); };

  togSound.onclick = () => { settings.sound = !settings.sound; setBtn(togSound, settings.sound ? "On" : "Off"); saveSettings(); };
  togCRT.onclick = () => { settings.crt = !settings.crt; setBtn(togCRT, settings.crt ? "On" : "Off"); saveSettings(); };
  togMotion.onclick = () => { settings.reduceMotion = !settings.reduceMotion; setBtn(togMotion, settings.reduceMotion ? "On" : "Off"); saveSettings(); };
  togTouch.onclick = () => {
    settings.touch = (settings.touch === "auto") ? "on" : (settings.touch === "on" ? "off" : "auto");
    setBtn(togTouch, settings.touch.toUpperCase());
    applyTouchMode();
    saveSettings();
  };

  btnRefreshLB.onclick = () => refreshLeaderboard();

  function setBtn(el, text){ el.textContent = text; }

  // ================
  // Touch controls
  // ================
  const touchPad = document.getElementById("touchPad");
  const touchHint = document.getElementById("touchHint");
  const touchState = { left:false, right:false, thrust:false, fire:false, bomb:false, hyper:false };

  function bindTouchBtn(id, key) {
    const el = document.getElementById(id);
    const set = (v) => { touchState[key] = v; el.classList.toggle("active", v); };
    el.addEventListener("pointerdown", (e) => { set(true); ensureAudio(); e.preventDefault(); }, { passive:false });
    el.addEventListener("pointerup", () => set(false));
    el.addEventListener("pointercancel", () => set(false));
    el.addEventListener("pointerleave", () => set(false));
  }
  bindTouchBtn("tLeft", "left");
  bindTouchBtn("tRight", "right");
  bindTouchBtn("tThrust", "thrust");
  bindTouchBtn("tFire", "fire");
  bindTouchBtn("tBomb", "bomb");
  bindTouchBtn("tHyper", "hyper");

  function isTouchDevice() {
    return (navigator.maxTouchPoints || 0) > 0 || "ontouchstart" in window;
  }
  function applyTouchMode() {
    const show = (settings.touch === "on") || (settings.touch === "auto" && isTouchDevice());
    touchPad.classList.toggle("show", show);
    touchHint.classList.toggle("show", show);
    if (!show) {
      for (const k of Object.keys(touchState)) touchState[k] = false;
      touchHint.classList.remove("show");
    } else {
      setTimeout(() => touchHint.classList.remove("show"), 3500);
    }
  }
  applyTouchMode();

  // ================
  // Service worker (PWA)
  // ================
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("sw.js").catch(()=>{});
  }

  // ================
  // Audio (WebAudio)
  // ================
  let audioCtx = null;
  let masterGain = null;

  function ensureAudio() {
    if (!settings.sound) return;
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.22;
    masterGain.connect(audioCtx.destination);
  }

  function beep(freq = 440, dur = 0.06, type = "square", gain = 0.6) {
    if (!settings.sound) return;
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = 0.0001;
    o.connect(g);
    g.connect(masterGain);

    const t = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t + 0.008);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

    o.start(t);
    o.stop(t + dur + 0.02);
  }

  function noiseBurst(dur = 0.12, gain = 0.5) {
    if (!settings.sound) return;
    if (!audioCtx) return;
    const bufferSize = Math.floor(audioCtx.sampleRate * dur);
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random()*2-1) * Math.pow(1 - i/bufferSize, 2);

    const src = audioCtx.createBufferSource();
    src.buffer = buffer;

    const g = audioCtx.createGain();
    g.gain.value = gain;

    src.connect(g);
    g.connect(masterGain);
    src.start();
  }

  addEventListener("pointerdown", () => { ensureAudio(); if (audioCtx?.state === "suspended") audioCtx.resume(); }, { once:true });
  addEventListener("keydown", () => { ensureAudio(); if (audioCtx?.state === "suspended") audioCtx.resume(); }, { once:true });

  // ================
  // Input (keyboard)
  // ================
  const keys = new Set();
  addEventListener("keydown", (e) => {
    if (e.code === "KeyP") paused = !paused;
    if (e.code === "KeyO") drawer.classList.toggle("open");
    keys.add(e.code);
    if (["ArrowLeft","ArrowRight","ArrowUp","Space","ShiftLeft","ShiftRight"].includes(e.code)) e.preventDefault();
  }, { passive:false });
  addEventListener("keyup", (e) => keys.delete(e.code));

  // ================
  // Visuals
  // ================
  const VISUALS = {
    glow: 18,
    scanlineAlpha: 0.07,
    vignetteAlpha: 0.38,
    shake: 0,
    flash: 0,
    starLayers: [
      { count: 150, speed: 0.12, size: 1, alpha: 0.28 },
      { count: 100, speed: 0.28, size: 2, alpha: 0.45 },
      { count: 60,  speed: 0.55, size: 3, alpha: 0.68 },
    ]
  };

  // ================
  // Game tunables
  // ================
  const WORLD_W = 7000;
  const GROUND_N = 0.84;
  const SHIP_TURN = 3.3;
  const SHIP_THRUST = 460;
  const FRICTION = 0.992;

  const BULLET_SPEED = 920;
  const BULLET_LIFE = 1.15;
  const FIRE_RATE = 0.11;

  const LANDER_BASE = 110;
  const MUTANT_BASE = 170;

  const ENEMY_SPAWN_BASE = 1.45;
  const MAX_ENEMIES = 22;

  const RESCUE_RADIUS_X = 92;
  const RESCUE_RADIUS_Y = 130;

  // ================
  // Daily seed + deterministic RNG
  // ================
  function dailySeedUTC() {
    const d = new Date();
    return d.getUTCFullYear() * 10000 + (d.getUTCMonth()+1) * 100 + d.getUTCDate();
  }
  let seed = dailySeedUTC();
  function srand(s){ seed = (s >>> 0) || 1; }
  function srnd() {
    // LCG
    seed = (seed * 1664525 + 1013904223) >>> 0;
    return seed / 4294967296;
  }

  // ================
  // Terrain
  // ================
  let camX = 0;
  function groundY() { return innerHeight * GROUND_N; }
  function terrainHeightAt(worldX) {
    const x = worldX;
    const a = Math.sin(x * 0.0018) * 16;
    const b = Math.sin(x * 0.0062) * 9;
    const c = Math.sin(x * 0.013)  * 5;
    return a + b + c;
  }

  // ================
  // Entities
  // ================
  const ship = {
    x: WORLD_W * 0.5, y: 280,
    vx: 0, vy: 0,
    a: 0, r: 15,
    lives: 3,
    invuln: 0,
    hyperspaceCD: 0,
    smartBombs: 3,
  };

  const bullets = [];
  const enemies = [];
  const particles = [];
  const humans = [];

  const HUMAN_COUNT = 16;
  for (let i = 0; i < HUMAN_COUNT; i++) {
    humans.push({
      x: (i + 0.5) * (WORLD_W / HUMAN_COUNT) + rand(-160, 160),
      alive: true,
      rescued: false,
      carriedBy: null,
      wobble: rand(0, Math.PI*2),
    });
  }

  // ================
  // Game state
  // ================
  let mode = "attract"; // attract | play | gameover
  let score = 0;
  let hi = Math.max(0, Number(localStorage.getItem("defender_hi") || 0));
  let level = 1;
  let paused = false;
  let spawnTimer = 0;
  let time = 0;
  let dailyMode = true; // default: daily challenge feel

  // ================
  // Stars
  // ================
  const stars = VISUALS.starLayers.map(layer =>
    Array.from({ length: layer.count }, () => ({ x: Math.random(), y: Math.random(), r: layer.size }))
  );

  // ================
  // Leaderboard (GitHub Issues)
  // ================
  async function refreshLeaderboard() {
    lbEl.textContent = "Loading leaderboard…";
    try {
      // label "score" recommended; if not, still parse recent issues
      const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/issues?state=open&per_page=50&labels=score`;
      const res = await fetch(url, { headers: { "Accept": "application/vnd.github+json" } });
      if (!res.ok) throw new Error("GitHub API rate limit or fetch error.");
      const issues = await res.json();

      const entries = [];
      for (const it of issues) {
        if (!it.body) continue;
        const parsed = parseScoreIssue(it.body);
        if (!parsed) continue;
        entries.push({
          user: parsed.user,
          score: parsed.score,
          level: parsed.level,
          seed: parsed.seed,
          url: it.html_url,
          created: it.created_at
        });
      }

      // show: today's seed first, then all-time
      const today = dailySeedUTC();
      const todays = entries.filter(e => e.seed === today).sort((a,b)=>b.score-a.score).slice(0, 10);
      const all = entries.sort((a,b)=>b.score-a.score).slice(0, 10);

      let out = "";
      out += `TOP 10 — TODAY (Seed ${today})\n`;
      out += todays.length ? todays.map((e,i)=>`${i+1}. ${e.user} — ${e.score} (L${e.level})`).join("\n") : "No scores yet. Be the first.\n";
      out += `\n\nTOP 10 — ALL TIME\n`;
      out += all.length ? all.map((e,i)=>`${i+1}. ${e.user} — ${e.score} (Seed ${e.seed})`).join("\n") : "No scores found.\n";

      out += `\n\nTip: score submissions are GitHub Issues labeled 'score'.`;
      lbEl.textContent = out;
    } catch (e) {
      lbEl.textContent = `Couldn't load leaderboard.\n${String(e.message || e)}`;
    }
  }

  function parseScoreIssue(body) {
    // Expected lines:
    // Reddit: Name
    // Score: 123
    // Level: 4
    // Seed: 20251217
    const get = (k) => {
      const m = body.match(new RegExp(`^\\s*${k}\\s*:\\s*(.+)\\s*$`, "mi"));
      return m ? m[1].trim() : null;
    };
    const user = get("Reddit") || get("User") || get("Username");
    const scoreStr = get("Score");
    const levelStr = get("Level");
    const seedStr = get("Seed");
    if (!user || !scoreStr || !seedStr) return null;
    const score = Number(scoreStr.replace(/[^\d]/g,""));
    const level = Number((levelStr||"1").replace(/[^\d]/g,"")) || 1;
    const seed = Number(seedStr.replace(/[^\d]/g,""));
    if (!Number.isFinite(score) || !Number.isFinite(seed)) return null;
    return { user, score, level, seed };
  }

  // initial load (lazy)
  setTimeout(refreshLeaderboard, 800);

  // ================
  // Spawning + types
  // ================
  function spawnLander() {
    if (enemies.length >= MAX_ENEMIES) return;
    const side = srnd() < 0.5 ? -1 : 1;
    const x = wrap(ship.x + side * (600 + srnd()*800), WORLD_W);
    const y = 110 + srnd()*310;
    const dir = srnd() < 0.5 ? -1 : 1;

    enemies.push({
      type: "lander",
      x, y,
      vx: dir * (LANDER_BASE + level * 7),
      vy: (srnd()*2-1) * 22,
      r: 16,
      mode: "patrol", // patrol | abduct | carry
      targetHuman: null,
      hp: 1,
    });
  }

  function spawnMutant(x, y) {
    enemies.push({
      type: "mutant",
      x: wrap(x, WORLD_W),
      y: clamp(y, 90, 540),
      vx: (srnd()*2-1) * (MUTANT_BASE + level * 10),
      vy: (srnd()*2-1) * 60,
      r: 17,
      mode: "hunt",
      hp: 1,
    });
  }

  function pickHumanForEnemy(e) {
    let best = null, bestD = Infinity;
    for (const h of humans) {
      if (!h.alive || h.rescued || h.carriedBy) continue;
      let dx = Math.abs(wrapDx(h.x - e.x, WORLD_W));
      const d = dx*dx;
      if (d < bestD) { bestD = d; best = h; }
    }
    return best;
  }

  // ================
  // Particles / effects
  // ================
  function addExplosion(wx, wy, color = "#ffffff", count = 24, power = 260) {
    if (!settings.reduceMotion) {
      VISUALS.shake = Math.min(18, VISUALS.shake + 10);
      VISUALS.flash = Math.min(0.65, VISUALS.flash + 0.35);
    }
    noiseBurst(0.09, 0.35);
    beep(160 + srnd()*80, 0.08, "sawtooth", 0.45);

    for (let i = 0; i < count; i++) {
      const ang = srnd() * Math.PI * 2;
      const sp = (power*0.35) + srnd() * (power*0.65);
      particles.push({
        x: wx, y: wy,
        vx: Math.cos(ang) * sp,
        vy: Math.sin(ang) * sp,
        life: 0.35 + srnd() * 0.55,
        t: 0,
        size: 1.5 + srnd() * 1.8,
        color,
      });
    }
  }

  // ================
  // Combat
  // ================
  function killEnemy(idx) {
    const e = enemies[idx];
    if (!e) return;

    if (e.type === "lander" && e.mode === "carry" && e.targetHuman) {
      e.targetHuman.carriedBy = null;
      e.targetHuman.wobble += 1.0;
    }

    addExplosion(e.x, e.y, e.type === "mutant" ? "#ff6ad5" : "#9dffea", 26, 290);
    enemies.splice(idx, 1);

    score += (e.type === "mutant") ? 250 : 150;
    hi = Math.max(hi, score);
    localStorage.setItem("defender_hi", String(hi));

    if (score > level * 2600) {
      level++;
      if (level % 3 === 0) ship.smartBombs = Math.min(5, ship.smartBombs + 1);
    }
  }

  function shipHit() {
    if (ship.invuln > 0) return;
    ship.lives--;
    ship.invuln = 2.0;

    if (!settings.reduceMotion) {
      VISUALS.shake = Math.min(22, VISUALS.shake + 16);
      VISUALS.flash = Math.min(0.8, VISUALS.flash + 0.45);
    }
    beep(90, 0.14, "square", 0.55);
    noiseBurst(0.1, 0.4);

    ship.vx *= -0.25;
    ship.vy *= -0.25;

    if (ship.lives <= 0) {
      mode = "gameover";
    }
  }

  // ================
  // Shooting / Smart bomb / Hyperspace
  // ================
  let fireCooldown = 0;
  function fire() {
    if (fireCooldown > 0) return;
    fireCooldown = FIRE_RATE;
    beep(620 + srnd()*140, 0.045, "square", 0.35);

    const bx = ship.x + Math.cos(ship.a) * (ship.r + 7);
    const by = ship.y + Math.sin(ship.a) * (ship.r + 7);
    bullets.push({
      x: wrap(bx, WORLD_W),
      y: by,
      vx: ship.vx + Math.cos(ship.a) * BULLET_SPEED,
      vy: ship.vy + Math.sin(ship.a) * BULLET_SPEED,
      t: 0
    });
  }

  function hyperspace() {
    if (ship.hyperspaceCD > 0) return;
    ship.hyperspaceCD = 3.0;
    ship.x = srnd() * WORLD_W;
    ship.y = 120 + srnd() * 320;
    ship.vx *= 0.2; ship.vy *= 0.2;
    ship.invuln = 0.75;
    beep(520, 0.07, "triangle", 0.35);

    if (srnd() < 0.07) shipHit();
  }

  let smartBombCD = 0;
  function smartBomb() {
    if (smartBombCD > 0 || ship.smartBombs <= 0) return;
    ship.smartBombs--;
    smartBombCD = 1.2;

    if (!settings.reduceMotion) {
      VISUALS.flash = Math.min(1.0, VISUALS.flash + 0.95);
      VISUALS.shake = Math.min(26, VISUALS.shake + 22);
    }
    beep(180, 0.12, "sawtooth", 0.55);
    beep(120, 0.16, "triangle", 0.45);
    noiseBurst(0.14, 0.55);

    for (let i = enemies.length - 1; i >= 0; i--) {
      const dx = Math.abs(wrapDx(enemies[i].x - ship.x, WORLD_W));
      if (dx < innerWidth * 0.75) killEnemy(i);
    }
  }

  // ================
  // Reset / Start
  // ================
  function resetGame({ daily=true } = {}) {
    score = 0;
    level = 1;
    dailyMode = daily;

    // daily seed makes runs comparable; non-daily uses time-based seed
    const s = daily ? dailySeedUTC() : (Date.now() >>> 0);
    srand(s);

    ship.x = WORLD_W * 0.5;
    ship.y = 280;
    ship.vx = ship.vy = 0;
    ship.a = 0;
    ship.lives = 3;
    ship.invuln = 1.2;
    ship.hyperspaceCD = 0;
    ship.smartBombs = 3;

    bullets.length = 0;
    enemies.length = 0;
    particles.length = 0;

    spawnTimer = 0;
    time = 0;
    paused = false;

    VISUALS.shake = 0;
    VISUALS.flash = 0;

    for (const h of humans) {
      h.alive = true;
      h.rescued = false;
      h.carriedBy = null;
      h.wobble = rand(0, Math.PI*2);
    }

    mode = "play";
  }

  btnPlay.onclick = () => resetGame({ daily:false });
  btnDaily.onclick = () => resetGame({ daily:true });

  // Share button: copies a Reddit-ready brag line
  btnShare.onclick = async () => {
    const seedTxt = dailyMode ? `Seed ${dailySeedUTC()}` : `Seed ${seed}`;
    const line = `I scored ${score} in Defender Deluxe (${seedTxt}) — play: ${REPO_PAGES_URL}`;
    try {
      await navigator.clipboard.writeText(line);
      lbEl.textContent = `Copied to clipboard:\n${line}`;
      drawer.classList.add("open");
    } catch {
      lbEl.textContent = `Copy failed. Here's the text:\n${line}`;
      drawer.classList.add("open");
    }
  };

  // ================
  // Submit score -> GitHub Issues (no backend)
  // ================
  function openSubmitScore() {
    const reddit = (settings.redditName || "Anonymous").trim() || "Anonymous";
    const seedTxt = dailyMode ? dailySeedUTC() : seed;
    const body =
`Reddit: ${reddit}
Score: ${score}
Level: ${level}
Seed: ${seedTxt}

Notes:
- Daily mode scores should use the daily seed for fair comparison.
- Please keep one best submission per day per user.

(Submitted from ${REPO_PAGES_URL})`;

    const title = `Score: ${score} — ${reddit} — Seed ${seedTxt}`;
    const url = `https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}/issues/new?labels=score&title=${encodeURIComponent(title)}&body=${encodeURIComponent(body)}`;
    window.open(url, "_blank");
  }

  // ================
  // Attract screen demo movement (no gameplay)
  // ================
  function drawAttractScreen() {
    // gentle auto-scroll
    camX = wrap(camX + 0.6, WORLD_W);

    drawBackground();
    drawTerrainAndCities();

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.shadowColor = "#9dffea";
    ctx.shadowBlur = 22;

    ctx.fillStyle = "#ffffff";
    ctx.font = "88px Arial Black, sans-serif";
    ctx.fillText("DEFENDER", innerWidth/2, innerHeight*0.36);

    ctx.fillStyle = "#9dffea";
    ctx.font = "64px Arial Black, sans-serif";
    ctx.fillText("DELUXE", innerWidth/2, innerHeight*0.45);

    ctx.shadowBlur = 0;
    ctx.font = "20px system-ui, sans-serif";
    ctx.fillStyle = "#cfe0ff";
    ctx.fillText("PURE CANVAS · NO ASSETS · DAILY CHALLENGE · GITHUB LEADERBOARD",
      innerWidth/2, innerHeight*0.53);

    if (Math.floor(time * 2) % 2 === 0) {
      ctx.font = "28px Arial Black, sans-serif";
      ctx.fillStyle = "#ffe2a8";
      ctx.fillText("PRESS ENTER TO START",
        innerWidth/2, innerHeight*0.62);
    }

    ctx.font = "16px system-ui, sans-serif";
    ctx.fillStyle = "rgba(215,224,255,0.80)";
    ctx.fillText("← → rotate · ↑ thrust · Space fire · Shift hyperspace · B smart bomb · P pause",
      innerWidth/2, innerHeight*0.72);

    ctx.fillStyle = "rgba(215,224,255,0.65)";
    ctx.fillText("Tip: Play Daily for the global leaderboard seed. Share your run.",
      innerWidth/2, innerHeight*0.77);

    ctx.restore();

    if (settings.crt) drawScanlinesAndFlash();
  }

  // ================
  // World -> screen X
  // ================
  function worldToScreenX(wx) {
    let x = wx - camX;
    if (x > WORLD_W/2) x -= WORLD_W;
    if (x < -WORLD_W/2) x += WORLD_W;
    return x;
  }

  // ================
  // Rendering
  // ================
  function drawBackground() {
    ctx.fillStyle = "#03040a";
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    const g = ctx.createRadialGradient(
      innerWidth * 0.28, innerHeight * 0.42, 60,
      innerWidth * 0.28, innerHeight * 0.42, innerWidth * 1.05
    );
    g.addColorStop(0, "rgba(55,105,180,0.14)");
    g.addColorStop(0.55, "rgba(110,50,150,0.08)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    VISUALS.starLayers.forEach((layer, i) => {
      ctx.fillStyle = `rgba(225,240,255,${layer.alpha})`;
      const arr = stars[i];
      for (const s of arr) {
        const x = ((s.x * innerWidth) - camX * layer.speed) % innerWidth;
        const y = s.y * innerHeight * 0.78;
        ctx.fillRect(x < 0 ? x + innerWidth : x, y, s.r, s.r);
      }
    });

    const vg = ctx.createRadialGradient(
      innerWidth/2, innerHeight/2, innerWidth*0.18,
      innerWidth/2, innerHeight/2, innerWidth*0.78
    );
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, `rgba(0,0,0,${VISUALS.vignetteAlpha})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, innerWidth, innerHeight);
  }

  function drawTerrainAndCities() {
    const gy = groundY();

    ctx.strokeStyle = "rgba(207,224,255,0.14)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, gy);
    ctx.lineTo(innerWidth, gy);
    ctx.stroke();

    ctx.fillStyle = "rgba(20,28,55,0.75)";
    ctx.beginPath();
    ctx.moveTo(0, innerHeight);
    const step = 18;
    for (let x = 0; x <= innerWidth; x += step) {
      const wx = camX + x;
      const h = 26 + terrainHeightAt(wx);
      ctx.lineTo(x, gy + h);
    }
    ctx.lineTo(innerWidth, innerHeight);
    ctx.closePath();
    ctx.fill();

    for (let x = 0; x <= innerWidth; x += 38) {
      const wx = camX + x;
      const h = 26 + terrainHeightAt(wx);
      const y = gy + h - 4;
      const tw = 0.35 + 0.65 * Math.max(0, Math.sin((wx * 0.004) + time * 5.2));
      const a = 0.06 + tw * 0.18;
      ctx.fillStyle = `rgba(255,226,168,${a})`;
      ctx.fillRect(x, y, 2, 1);
      if ((Math.floor(wx * 0.02) % 7) === 0) ctx.fillRect(x + 4, y - 1, 1, 2);
    }
  }

  function drawHumans() {
    const baseY = groundY() - 14;
    for (const h of humans) {
      if (!h.alive) continue;

      const sx = worldToScreenX(h.x);
      const bob = Math.sin(time * 3.2 + h.wobble) * 2;
      const hy = h.carriedBy ? (h.carriedBy.y + 18) : (baseY + bob + terrainHeightAt(h.x));

      if (h.rescued) {
        ctx.save();
        ctx.shadowColor = "#ffe2a8";
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(sx, hy, 4.2, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,226,168,0.85)";
        ctx.fill();
        ctx.restore();
        continue;
      }

      ctx.save();
      ctx.shadowColor = "#cfe0ff";
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(sx, hy, 3.2, 0, Math.PI*2);
      ctx.fillStyle = "rgba(207,224,255,0.9)";
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(sx - 4, hy + 3); ctx.lineTo(sx + 4, hy + 3);
      ctx.strokeStyle = "rgba(207,224,255,0.55)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawParticles() {
    for (const p of particles) {
      const sx = worldToScreenX(p.x);
      const k = 1 - (p.t / p.life);
      ctx.save();
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 16;
      ctx.globalAlpha = clamp(k, 0, 1);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(sx, p.y, p.size * (0.7 + k*0.6), 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawShip() {
    const sx = worldToScreenX(ship.x);
    const sy = ship.y;

    ctx.save();
    ctx.translate(sx, sy);
    ctx.rotate(ship.a);

    const flicker = ship.invuln > 0 && Math.floor(time * 18) % 2 === 0;
    ctx.globalAlpha = flicker ? 0.42 : 1;

    ctx.shadowColor = "#7fd6ff";
    ctx.shadowBlur = VISUALS.glow;
    ctx.strokeStyle = "#dff3ff";
    ctx.lineWidth = 2.3;

    ctx.beginPath();
    ctx.moveTo(24, 0);
    ctx.lineTo(-16, -13);
    ctx.lineTo(-7, 0);
    ctx.lineTo(-16, 13);
    ctx.closePath();
    ctx.stroke();

    ctx.shadowColor = "#9dffea";
    ctx.shadowBlur = 14;
    ctx.beginPath();
    ctx.arc(5, 0, 3.4, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(157,255,234,0.95)";
    ctx.stroke();

    if (inputThrust()) {
      ctx.shadowColor = "#ffb86c";
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.moveTo(-14, 0);
      ctx.lineTo(-30 - srnd()*10, -4);
      ctx.lineTo(-22, 0);
      ctx.lineTo(-30 - srnd()*10, 4);
      ctx.closePath();
      ctx.strokeStyle = "rgba(255,226,168,0.9)";
      ctx.stroke();
    }

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawEnemy(e) {
    const sx = worldToScreenX(e.x);
    const sy = e.y;

    ctx.save();
    ctx.translate(sx, sy);

    if (e.type === "lander") {
      ctx.shadowColor = "#9dffea";
      ctx.shadowBlur = 16;
      ctx.strokeStyle = "#dffcff";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 12, 0, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-12, 0); ctx.lineTo(12, 0);
      ctx.strokeStyle = "rgba(157,255,234,0.35)";
      ctx.lineWidth = 1;
      ctx.stroke();

      if (e.mode === "abduct" || e.mode === "carry") {
        ctx.beginPath();
        ctx.moveTo(0, 10);
        ctx.lineTo(0, 28);
        ctx.strokeStyle = "rgba(255,226,168,0.35)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    } else {
      ctx.shadowColor = "#ff6ad5";
      ctx.shadowBlur = 18;
      ctx.strokeStyle = "rgba(255,214,242,0.95)";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(0, -16);
      ctx.lineTo(14, 0);
      ctx.lineTo(0, 16);
      ctx.lineTo(-14, 0);
      ctx.closePath();
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-8, 0); ctx.lineTo(8, 0);
      ctx.moveTo(0, -8); ctx.lineTo(0, 8);
      ctx.strokeStyle = "rgba(255,106,213,0.35)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawBullet(b) {
    const sx = worldToScreenX(b.x);
    ctx.save();
    ctx.shadowColor = "#ffffff";
    ctx.shadowBlur = 14;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(sx, b.y, 2.8, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawHUD() {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.0)";
    ctx.fillRect(0,0,1,1);
    ctx.restore();

    // Minimal on-canvas HUD (UI panel already exists). Add seed info top-right subtly:
    ctx.save();
    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.fillStyle = "rgba(215,224,255,0.70)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const seedTxt = dailyMode ? `DAILY ${dailySeedUTC()}` : `SEED ${seed}`;
    ctx.fillText(`${seedTxt}  SCORE ${score}  L${level}  ♥${ship.lives}  B${ship.smartBombs}`, innerWidth - 12, 12);
    ctx.restore();
  }

  function drawScanlinesAndFlash() {
    if (VISUALS.flash > 0) {
      ctx.save();
      ctx.fillStyle = `rgba(255,255,255,${VISUALS.flash * 0.35})`;
      ctx.fillRect(0, 0, innerWidth, innerHeight);
      ctx.restore();
    }
    if (!settings.crt) return;
    ctx.save();
    ctx.fillStyle = `rgba(0,0,0,${VISUALS.scanlineAlpha})`;
    for (let y = 0; y < innerHeight; y += 2) ctx.fillRect(0, y, innerWidth, 1);
    ctx.restore();
  }

  function drawOverlay(title, subtitle, extra) {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.60)";
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.shadowColor = "#9dffea";
    ctx.shadowBlur = 18;

    ctx.fillStyle = "#ffffff";
    ctx.font = "56px Arial Black, sans-serif";
    ctx.fillText(title, innerWidth/2, innerHeight/2 - 40);

    ctx.shadowBlur = 0;
    ctx.fillStyle = "#cfe0ff";
    ctx.font = "18px system-ui, sans-serif";
    ctx.fillText(subtitle, innerWidth/2, innerHeight/2 + 10);

    if (extra) {
      ctx.fillStyle = "rgba(255,226,168,0.95)";
      ctx.font = "16px system-ui, sans-serif";
      ctx.fillText(extra, innerWidth/2, innerHeight/2 + 44);
    }
    ctx.restore();
  }

  // ================
  // Input adapters
  // ================
  function inputLeft()  { return keys.has("ArrowLeft") || touchState.left; }
  function inputRight() { return keys.has("ArrowRight") || touchState.right; }
  function inputThrust(){ return keys.has("ArrowUp") || touchState.thrust; }
  function inputFire()  { return keys.has("Space") || touchState.fire; }
  function inputBomb()  { return keys.has("KeyB") || touchState.bomb; }
  function inputHyper() { return keys.has("ShiftLeft") || keys.has("ShiftRight") || touchState.hyper; }

  // ================
  // Game update
  // ================
  let smartBombCD = 0;

  function update(dt) {
    time += dt;

    if (mode !== "play") return;

    // Spawn pacing (deterministic in daily mode)
    spawnTimer += dt;
    const spawnInterval = Math.max(0.55, ENEMY_SPAWN_BASE - level * 0.07);
    if (spawnTimer >= spawnInterval) {
      spawnTimer = 0;
      if (srnd() < Math.min(0.22, 0.06 + level * 0.015)) {
        spawnMutant(ship.x + (srnd()*2-1) * 1300, 120 + srnd()*320);
      } else {
        spawnLander();
      }
    }

    // Input & physics
    if (inputLeft()) ship.a -= SHIP_TURN * dt;
    if (inputRight()) ship.a += SHIP_TURN * dt;

    if (inputThrust()) {
      ship.vx += Math.cos(ship.a) * SHIP_THRUST * dt;
      ship.vy += Math.sin(ship.a) * SHIP_THRUST * dt;
      if (srnd() < 0.14) addThrustParticle();
    }

    if (inputFire()) fire();
    if (inputHyper()) hyperspace();
    if (inputBomb()) smartBomb();

    fireCooldown = Math.max(0, fireCooldown - dt);
    smartBombCD = Math.max(0, smartBombCD - dt);
    ship.invuln = Math.max(0, ship.invuln - dt);
    ship.hyperspaceCD = Math.max(0, ship.hyperspaceCD - dt);

    ship.vx *= Math.pow(FRICTION, dt * 60);
    ship.vy *= Math.pow(FRICTION, dt * 60);

    ship.x = wrap(ship.x + ship.vx * dt, WORLD_W);
    ship.y = clamp(ship.y + ship.vy * dt, 60, 540);

    camX = ship.x - innerWidth * 0.5;

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.t += dt;
      b.x = wrap(b.x + b.vx * dt, WORLD_W);
      b.y += b.vy * dt;

      if (b.t > BULLET_LIFE || b.y < 15 || b.y > innerHeight - 15) {
        bullets.splice(i, 1);
        continue;
      }

      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (dist2(b.x, b.y, e.x, e.y) < (e.r + 4) * (e.r + 4)) {
          killEnemy(j);
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Humans rescue
    for (const h of humans) {
      if (!h.alive || h.rescued) continue;
      if (h.carriedBy) { h.x = wrap(h.carriedBy.x, WORLD_W); continue; }

      const dx = Math.abs(wrapDx(h.x - ship.x, WORLD_W));
      const dy = Math.abs((groundY() - 12) - ship.y);
      if (dx < RESCUE_RADIUS_X && dy < RESCUE_RADIUS_Y) {
        h.rescued = true;
        score += 250;
        hi = Math.max(hi, score);
        localStorage.setItem("defender_hi", String(hi));
        beep(880, 0.06, "triangle", 0.33);
      }
    }

    // Enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];

      if (e.type === "lander") {
        if (e.mode === "patrol") {
          if (srnd() < (0.015 + level * 0.002)) {
            const h = pickHumanForEnemy(e);
            if (h) { e.targetHuman = h; e.mode = "abduct"; }
          }
        }

        if (e.mode === "abduct" && e.targetHuman && e.targetHuman.alive && !e.targetHuman.rescued && !e.targetHuman.carriedBy) {
          const tx = e.targetHuman.x;
          let dx = wrapDx(tx - e.x, WORLD_W);
          e.vx += clamp(dx, -230, 230) * 0.006 * dt * 60;

          const ty = groundY() - 18 + terrainHeightAt(tx);
          e.vy += clamp(ty - e.y, -230, 230) * 0.010 * dt * 60;

          if (dist2(e.x, e.y, tx, ty) < 34*34) {
            e.mode = "carry";
            e.targetHuman.carriedBy = e;
            score = Math.max(0, score - 50);
            beep(220, 0.07, "square", 0.35);
          }
        } else if (e.mode === "abduct") {
          e.mode = "patrol";
          e.targetHuman = null;
        }

        if (e.mode === "carry") {
          e.vy -= (48 + level * 4) * dt;
          if (e.targetHuman && e.y < 70) {
            e.targetHuman.alive = false;
            e.targetHuman.carriedBy = null;
            const hx = e.targetHuman.x;
            e.targetHuman = null;
            e.mode = "patrol";
            spawnMutant(hx, 140);
            beep(140, 0.09, "sawtooth", 0.45);
          }
        }

        e.x = wrap(e.x + e.vx * dt, WORLD_W);
        e.y += e.vy * dt;

        if (e.y < 70) { e.y = 70; e.vy = Math.abs(e.vy) * 0.6; }
        if (e.y > 540) { e.y = 540; e.vy = -Math.abs(e.vy) * 0.6; }

        e.vx *= 0.999;
        e.vy *= 0.994;

      } else {
        let dx = wrapDx(ship.x - e.x, WORLD_W);
        let dy = (ship.y - e.y);
        const ax = clamp(dx, -400, 400) * 0.010;
        const ay = clamp(dy, -280, 280) * 0.012;

        e.vx += ax * dt * 60;
        e.vy += ay * dt * 60;

        const maxSp = MUTANT_BASE + level * 16;
        const sp = Math.hypot(e.vx, e.vy);
        if (sp > maxSp) { e.vx = (e.vx/sp)*maxSp; e.vy = (e.vy/sp)*maxSp; }

        e.x = wrap(e.x + e.vx * dt, WORLD_W);
        e.y = clamp(e.y + e.vy * dt, 70, 540);

        e.vx *= 0.998;
        e.vy *= 0.996;
      }

      // Collision with ship
      const rr = e.r + ship.r;
      if (dist2(e.x, e.y, ship.x, ship.y) < rr*rr) {
        shipHit();
        const ang = Math.atan2(e.y - ship.y, wrapDx(e.x - ship.x, WORLD_W));
        e.vx += Math.cos(ang) * 140;
        e.vy += Math.sin(ang) * 140;
      }
    }

    // Particles update
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.t += dt;
      p.x = wrap(p.x + p.vx * dt, WORLD_W);
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.985, dt * 60);
      p.vy *= Math.pow(0.985, dt * 60);
      if (p.t > p.life) particles.splice(i, 1);
    }

    VISUALS.shake = Math.max(0, VISUALS.shake - (settings.reduceMotion ? 80 : 28) * dt);
    VISUALS.flash = Math.max(0, VISUALS.flash - (settings.reduceMotion ? 4.0 : 1.7) * dt);
  }

  function addThrustParticle() {
    const wx = ship.x - Math.cos(ship.a) * (ship.r + 8);
    const wy = ship.y - Math.sin(ship.a) * (ship.r + 8);
    const ang = ship.a + Math.PI + (srnd()*2-1) * 0.35;
    const sp = 120 + srnd()*130;
    particles.push({
      x: wrap(wx, WORLD_W),
      y: wy,
      vx: Math.cos(ang) * sp + ship.vx * 0.2,
      vy: Math.sin(ang) * sp + ship.vy * 0.2,
      life: 0.18 + srnd()*0.17,
      t: 0,
      size: 1.0 + srnd()*1.0,
      color: "#ffb86c",
    });
  }

  // ================
  // Main loop / render
  // ================
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (!paused) update(dt);

    // Render
    const shake = settings.reduceMotion ? 0 : VISUALS.shake;
    const ox = shake > 0 ? rand(-shake, shake) : 0;
    const oy = shake > 0 ? rand(-shake, shake) : 0;

    ctx.save();
    ctx.translate(ox, oy);

    if (mode === "attract") {
      drawAttractScreen();
      ctx.restore();
      return requestAnimationFrame(loop);
    }

    drawBackground();
    drawTerrainAndCities();
    drawHumans();
    for (const b of bullets) drawBullet(b);
    drawParticles();
    for (const e of enemies) drawEnemy(e);
    drawShip();

    ctx.restore();

    drawHUD();

    if (settings.crt || VISUALS.flash > 0) drawScanlinesAndFlash();

    if (paused && mode === "play") drawOverlay("PAUSED", "Press P to resume", "Press O for Options");
    if (mode === "gameover") {
      drawOverlay("GAME OVER", `Score ${score} · Level ${level}`, "Press S to submit score · Enter to restart");
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ================
  // Key actions: start / restart / submit
  // ================
  addEventListener("keydown", (e) => {
    if (mode === "attract" && e.code === "Enter") resetGame({ daily:true });
    if (mode === "gameover" && e.code === "Enter") resetGame({ daily:true });
    if (mode === "gameover" && e.code === "KeyS") openSubmitScore();
  });

  // ================
  // Buttons also start game
  // ================
  btnPlay.onclick = () => resetGame({ daily:false });
  btnDaily.onclick = () => resetGame({ daily:true });

})();
</script>
</body>
</html>
